#+TITLE: Emacs 初期化ファイルの本体
#+STARTUP: noptag
#+STARTUP: content
#+STARTUP: hidestars
#+STARTUP: indent
#+PROPERTY: padline no
#+PROPERTY: results silent
#+TAGS:  key(k) command(c) autoinstall(a) marmalade(m) elget(e) git(g) svn(s) rubikitch(r)

* ユーティリティ
** ディレクトリ構成
*** prefix
#+NAME: tnoda-dotfiles-dir
#+BEGIN_SRC emacs-lisp :tangle no :exports yes
  (eval tnoda/dotfiles-dir)
#+END_SRC

*** elisp\_dir
#+NAME: tnoda-elisp-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst tnoda/elisp-dir (expand-file-name "elisp" tnoda/dotfiles-dir)))
#+END_SRC

*** info\_dir
#+NAME: tnoda-info-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst tnoda/info-dir (expand-file-name "share/info" tnoda/dotfiles-dir)))
#+END_SRC

*** src\_dir
#+NAME: tnoda-src-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst tnoda/src-dir (expand-file-name "src" tnoda/dotfiles-dir)))
#+END_SRC

*** bin\_dir
#+NAME: tnoda-bin-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst tnoda/bin-dir (expand-file-name "bin" tnoda/dotfiles-dir))
#+END_SRC

*** emacs
#+NAME: emacs-app
#+BEGIN_EXAMPLE
  /Applications/Emacs.app/Contents/MacOS/Emacs
#+END_EXAMPLE

** 行間を広くする関数 =tnoda/increase-line-spacing=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/increase-line-spacing ()
    (setq line-spacing 4))
#+END_SRC

* パッケージ管理
** =~/.emacs.d/elisp= とそのサブディレクトリを =load-path= に追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((default-directory tnoda/elisp-dir))
    (add-to-list 'load-path default-directory)
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

** el-get                                                            :elget:
*** Install & Setup
#+NAME: el-get-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst el-get-dir
          (cond ((eq system-type 'darwin)
                 "/opt/el-get")
                ((eq system-type 'windows-nt)
                 (expand-file-name "el-get" tnoda/dotfiles-dir))
                (t nil))))

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((default-directory el-get-dir))
    (normal-top-level-add-subdirs-to-load-path))
  (add-to-list 'load-path (expand-file-name "el-get" el-get-dir))
  (unless (require 'el-get nil t)
    (url-retrieve
     "https://raw.github.com/dimitri/el-get/master/el-get-install.el"
     (lambda (s)
       (let (el-get-master-branch)
         (goto-char (point-max))
         (eval-print-last-sexp)))))
  (add-to-list 'el-get-recipe-path (expand-file-name "el-get-recipes" tnoda/dotfiles-dir))
  (el-get 'sync)

#+END_SRC

** MELPA/Marmalade
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'windows-nt)
    (package-initialize)
    (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
    (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t))

#+END_SRC


* Emacs

** Emacs 起動したらすぐ eshell を使えるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook 'eshell)
#+END_SRC

** メール
#+BEGIN_SRC emacs-lisp :tangle yes
  (load "~/.mail.el")
#+END_SRC

** Coding system in Windows settings
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'windows-nt)
    (setq default-file-name-coding-system 'cp932)
    (setq default-buffer-file-coding-system 'utf-8-unix)
    (setq default-process-coding-system '(cp932-dos . cp932-dos)))

#+END_SRC

** 表示
*** Full Screen; M-F toggles fullscreen.                                :key:

Originally retrieved from http://www.emacswiki.org/emacs/FullScreen#toc23, on 2013-07-07

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq window-system 'ns)
    (setq ns-use-native-fullscreen nil)
    
    (defun tnoda/toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      (if (frame-parameter nil 'fullscreen)
          (progn
            (set-frame-parameter nil 'fullscreen nil)
            (set-frame-position (selected-frame) 1 1)
            (set-frame-size (selected-frame) 80 42))
        (set-frame-parameter nil 'fullscreen 'fullboth)))

    (global-set-key (kbd "M-F") 'tnoda/toggle-fullscreen)
    (set-frame-parameter nil 'fullscreen 'fullboth))
#+END_SRC

*** =s-f= でフォント切り替え．                                            :key:

+ デフォルトは Inconsolata + ヒラギノ丸ゴ
+ =s-f= で拡大・縮小

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/fontset-setup-mac
    ()

    (defvar tnoda/current-fontset 'default)

    (defun tnoda/fontset-mac-default ()
      (set-face-attribute 'default nil
                          :family "Inconsolata"
                          :height 160)
      (set-fontset-font (frame-parameter nil 'font)
                        'japanese-jisx0208
                        (font-spec :family "Hiragino Maru Gothic ProN" :size 16))
      (set-fontset-font (frame-parameter nil 'font)
                        'mule-unicode-0100-24ff
                        (font-spec :family "Ricty" :size 16))
      (set-fontset-font nil
                        '(#x0370 . #x03FF)
                        (font-spec :family "Helvetica" :size 16))
      (setq tnoda/current-fontset 'default))

    (defun tnoda/fontset-mac-retina ()
      (set-face-attribute 'default nil
                          :family "Inconsolata"
                          :height 240)
      (set-fontset-font (frame-parameter nil 'font)
                        'japanese-jisx0208
                        (font-spec :family "Hiragino Maru Gothic ProN" :size 24))
      (set-fontset-font (frame-parameter nil 'font)
                        'mule-unicode-0100-24ff
                        (font-spec :family "Ricty" :size 24))
      (set-fontset-font nil
                        '(#x0370 . #x03FF)
                        (font-spec :family "Helvetica" :size 24))
      (setq tnoda/current-fontset 'retina))

    (defun tnoda/fontset-toggle ()
      (interactive)
      (case tnoda/current-fontset
        ('default
          (tnoda/fontset-mac-retina))
        ('retina
         (tnoda/fontset-mac-default))
        (t
         (error "invalid fontset"))))

    (tnoda/fontset-mac-default)
    (global-set-key (kbd "s-f") 'tnoda/fontset-toggle))

  (defun tnoda/fontset-setup-windows
    ()
    (set-face-attribute 'default nil
                        :family "Inconsolata"
                        :height 144)
    (set-fontset-font t 'japanese-jisx0208 (font-spec :family "Meiryo"))
    (set-fontset-font t 'katakana-jisx0201 (font-spec :family "Meiryo"))
    (set-fontset-font t 'japanese-jisx0212 (font-spec :family "Meiryo"))
    (setq face-font-rescale-alist '(("メイリオ" . 0.96))))

  (cond ((eq window-system 'ns)
         (tnoda/fontset-setup-mac))
        ((eq window-system 'w32)
         (tnoda/fontset-setup-windows)))

#+END_SRC

*** Apply solarized-dark theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'color-theme-solarized)

  (color-theme-initialize)
  (color-theme-solarized-dark)

#+END_SRC

*** ツールバーなどを表示しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
#+END_SRC

*** 現在行に色をつける．
#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (global-hl-line-mode 1)
    (set-face-background 'hl-line "black"))
#+END_SRC

*** 起動画面を表示しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-startup-message t)
#+END_SRC

*** =font-lock= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-font-lock-mode t)
#+END_SRC

*** 対応する括弧を表示させる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (show-paren-mode 1)
  (set-face-background 'show-paren-match-face "darkgreen")
#+END_SRC．

*** モードラインに時刻を表示させる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (display-time)
#+END_SRC

*** モードラインに行番号・列番号を表示させる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC

*** リージョンに色をつける．
#+BEGIN_SRC emacs-lisp :tangle yes
  (transient-mark-mode 1)
  (set-face-background 'region "blue")
#+END_SRC

*** カーソルを点滅させない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (blink-cursor-mode -1)
#+END_SRC

*** Ediff 関連のバッファを一つにまとめる．                        :rubikitch:

きっと auto-install.el で便利．

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

*** Define a command to notify trailing whitespaces.                :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/enable-show-trailing-whitespaces ()
    (interactive)
    (setq show-trailing-whitespace t))
#+END_SRC

*** Mac OS X
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/auto-install")

#+end_src

*** バッテリー残量を表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (display-battery-mode 1))

#+END_SRC

*** =browse-url= で Firefox を開く．                              :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "open"
          browse-url-generic-args '("-a" "Firefox")))

#+END_SRC

*** =<M-f1>= invokes Dictionary.app.                                    :key:

Thanks to http://d.hatena.ne.jp/tunefs/20130212/p1.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/dictionary ()
    "dictionary.app"
    (interactive)
    (let ((url (concat "dict://" (read-from-minibuffer "" (current-word)))))
      (browse-url url)))
  (global-set-key (kbd "<M-f1>") 'tnoda/dictionary)
#+END_SRC

** キーバインド
*** Mac OS X's modifier settings
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (setq mac-option-modifier 'super)
    (setq mac-command-modifier 'meta))

#+END_SRC

*** Windows key settings
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'windows-nt)
    (setq w32-pass-lwindow-to-system nil)
    (setq w32-lwindow-modifier 'meta))

#+END_SRC

*** =s-q= を無効に．誤爆したときのダメージが大きすぎる (=save-buffers-kill-emacs=) :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key (kbd "s-q"))
#+END_SRC

*** =C-h= で =delete-backward-char=.                                    :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-h" 'delete-backward-char)
#+END_SRC

*** =C-x o= を無効に．                                                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key (kbd "C-x o"))
#+END_SRC

*** =C-x C-b= で =ibuffer=.                                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-x\C-b" 'ibuffer)
#+END_SRC

*** =M-/= で =hippie-expand=.                                           :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

*** =C-z= で =eshell=.                                                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-z") 'eshell)
#+END_SRC

*** =C-x C-c= で =server-edit=. 代わりに =M-x ZZ= で Emacs を終了．     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-c") 'server-edit)
  (defalias 'ZZ 'save-buffers-kill-emacs)
#+END_SRC

*** =dired-mode= で =W= を押すと =wdired-mode= になる．                 :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key dired-mode-map "W" 'wdired-change-to-wdired-mode)
#+END_SRC

*** =C-;= でウィンドウ切替か水平分割． =C-:= で垂直分割．   :key:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/other-window-or-split-window-horizontally ()
    (interactive)
    (when (one-window-p) (split-window-horizontally))
    (other-window 1))
  (global-set-key (kbd "C-;") 'tnoda/other-window-or-split-window-horizontally)
  (global-set-key (kbd "C-:") 'split-window-vertically)
#+END_SRC

*** =C-M-;= で =follow-mode=                                :key:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-M-;") 'follow-delete-other-windows-and-split)
#+END_SRC

*** =<f5>= で =compile= か =executable-interpret=                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/script-p ()
      (and (>= (buffer-size) 2)
           (save-restriction
             (widen)
             (string= "#!" (buffer-substring (point-min) (+ 2 (point-min)))))))
  (defun tnoda/compile-or-executable-interpret ()
    (interactive)
    (cond ((tnoda/script-p)
           (call-interactively 'executable-interpret))
          (t
           (call-interactively 'compile))))
  (global-set-key (kbd "<f5>") 'tnoda/compile-or-executable-interpret)
#+END_SRC

*** =C-m= で改行してインデント．                                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-m") 'newline-and-indent)
#+END_SRC

*** =C-x 4 q= で =tnoda/View-quit-other-window=.                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/View-quit-other-window ()
    (interactive)
    (save-selected-window
      (other-window 1)
      (call-interactively 'View-quit)))
  (define-key ctl-x-4-map (kbd "q") 'tnoda/View-quit-other-window)
#+END_SRC

*** =s-a= で =tnoda/kill-ring-save-whole-buffer=.                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/kill-ring-save-whole-buffer ()
    (interactive)
    (save-excursion
      (copy-region-as-kill (point-min) (point-max))))
  (global-set-key (kbd "s-a") 'tnoda/kill-ring-save-whole-buffer)
#+END_SRC

** ログと履歴
*** ログの記録行数を増やす．                                    :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq message-log-max 10000)
#+END_SRC

*** ミニバッファを再帰的に呼び出せるようにする．                :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq enable-recursive-minibuffers t)
#+END_SRC

*** 履歴を沢山保存する．                                        :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq history-length 1000)
#+END_SRC

*** ミニバッファで入力を取り消しても履歴に残す．                :rubikitch:

誤取消で入力が失われるのを防ぐため．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice abort-recursive-edit (before minibuffer-save activate)
    (when (eq (selected-window) (active-minibuffer-window))
      (add-to-history minibuffer-history-variable (minibuffer-contents))))
#+END_SRC

*** ファイル内のカーソル位置を記憶する．                          :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default save-place t)
  (require 'saveplace)
#+END_SRC

** カレンダー
*** 現在位置を設定する．
+ =calendar-latitude=
+ =calendar-longitude=
+ =calendar-location-name=

#+BEGIN_SRC emacs-lisp :tangle yes
  (load "~/.calendar-location.el")
#+END_SRC

*** japanese-holidays.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'japanese-holidays)

  (setq calendar-holidays
        (append japanese-holidays local-holidays other-holidays))
  (setq mark-holidays-in-calendar t) ; 祝日をカレンダーに表示

  ;; (setq japanese-holiday-weekend '(0 6)     ; 土日を祝日として表示
  ;;       japanese-holiday-weekend-marker     ; 土曜日を水色で表示
  ;;       '(holiday nil nil nil nil nil japanese-holiday-saturday))
  ;; (add-hook 'calendar-today-visible-hook 'japanese-holiday-mark-weekend)
  ;; (add-hook 'calendar-today-invisible-hook 'japanese-holiday-mark-weekend))

#+END_SRC

** スクリプトファイルを保存するときには，モードを実行可能に設定する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** =exec-path=

*** Add =/Developer/usr/bin= to =exec-path=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path "/Developer/usr/bin")
#+END_SRC

*** =exec-path= に =~/.emacs.d/bin= を追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path tnoda/bin-dir)
#+END_SRC

*** =exec-path= に Homebrew を追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path "/opt/homebrew/bin")
#+END_SRC

*** =exec-path= に =/usr/texbin= を追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path "/usr/texbin")
#+END_SRC

** スペルチェック (ispell/aspell)
+ aspell を使う．
+ 英語日本語混じりの文章でエラーが出ないようなおまじない (ispell-skip-region-alist).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default ispell-program-name "aspell")
  (eval-after-load "ispell"
    '(add-to-list 'ispell-skip-region-alist '("[^\000-\377]+")))
#+END_SRC

*** =C-M-$= で =ispell-buffer=.                                       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-M-$") 'ispell-buffer)
#+END_SRC

** GC を減らして軽くする．                                       :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gc-cons-threshold (* 16 gc-cons-threshold))
#+END_SRC

** yes/no の代わりに y/n.
#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)  
#+END_SRC

** 新規ファイルを確認無しに作成する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

** ダイアログボックスを使わないようにする．                      :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq use-dialog-box nil)
  (defalias 'message-box 'message)
#+END_SRC

** キーストロークをエコーエリアに素早く表示する．                 :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq echo-keystrokes 0.1)
#+END_SRC

** 大きいファイルを開くときの警告を 32 MB 以上にする．             :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq large-file-warning-threshold (* 25 1025 1024))
#+END_SRC

** emacsclient
#+BEGIN_SRC emacs-lisp :tangle yes
  (server-start)
  (setq server-window 'pop-to-buffer)

#+END_SRC

** midnight: 深夜に不急と思われるバッファを消す．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'midnight)
#+END_SRC

** =shell-mode= のバッファを消すときに確認しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

** インデントにタブを使わない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
#+END_SRC

** 圧縮ファイルを読み書きできるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (auto-compression-mode t)
#+END_SRC

** Narrowing: (=C-x n n=), (=C-x n p=) を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** 環境変数 =MANPATH= を設定する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setenv "MANPATH" (mapconcat 'identity
                               (list (expand-file-name "shrea/man" tnoda/dotfiles-dir)
                                     "/opt/homebrew/share/man"
                                     "/Developer/usr/share/man"
                                     "/usr/share/man"
                                     "/usr/X11R6/man")
                               ":"))
#+END_SRC

** =~/.emacs.d/share/info= を優先する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/add-tnoda-info-dir-to-info-directory-list
    ()
    (add-to-list 'Info-directory-list tnoda/info-dir))

  (add-hook 'Info-mode-hook 'tnoda/add-tnoda-info-dir-to-info-directory-list)

#+END_SRC

** Unified diff を表示する．                                     :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq diff-switches "-u")
#+END_SRC

** =hi-lock-mode= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-hi-lock-mode 1)
#+END_SRC

** =C-x F=, =C-x K=, =C-x V=                                  :key:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (find-function-setup-keys)
#+END_SRC

** Conflict したマージファイルを開くときには =smerg-mode= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'smerge-mode)
  (defun tnoda/try-smerge ()
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward smerge-begin-re nil t)
        (smerge-mode 1))))
  (add-hook 'find-file-hook 'tnoda/try-smerge)
#+END_SRC

** Printing

+ Printing by =ps-print-buffer-with-faces=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ps-multibyte-buffer 'non-latin-printer)
  (setq ps-lpr-command "c:/Program Files/Ghostgum/gsview/gsview32.exe")
  (setq ps-lpr-switches nil)
  (setq ps-printer-name nil)
  (setq ps-printer-name-option nil)
  (setq ps-paper-type 'a4)
  (setq ps-line-number t)
  (setq ps-print-header t)
  (setq ps-print-color-p t)

#+END_SRC

** auto-insert
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'find-file-hook 'auto-insert)

#+END_SRC

** wdired
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired)
  (define-key dired-mode-map "e" 'wdired-change-to-wdired-mode)

#+END_SRC

* Global

** generic-x.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'generic-x)

#+END_SRC

** dash.el                                                           :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'dash)
#+END_SRC

** imenu.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'imenu)
  (setq imenu-max-item-length 80)
#+END_SRC

** subword-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/subword-mode-enable ()
    (subword-mode 1))
#+END_SRC

** smartrep.el                                                       :elget:
http://sheephead.homelinux.org/2012/01/30/6934/
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'smartrep)
  (require 'smartrep)
#+END_SRC

*** =M-g n n n ...=                                                   :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (smartrep-define-key
      global-map "M-g" '(("n"   . 'next-error)
                         ("p"   . 'previous-error)))
#+END_SRC
+ =M-g n= and =M-g p= are bound to =next-error= and =previous-error=
  using smartrep.el.
  - Pressing =M-g n n n ...=, you can visit the corresponding lines.

** bm.el                                                   :elget:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'bm)

#+END_SRC

*** =bm.el= ロード時にマークを復元する．Emacs を終了してもマークを復元できるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq bm-restore-repository-on-load t)
  (load "bm")
  (add-hook 'find-file-hook 'bm-buffer-restore)
  (add-hook 'kill-buffer-hook 'bm-buffer-save)
  (add-hook 'after-save-hook 'bm-buffer-save)
  (add-hook 'after-revert-hook 'bm-buffer-restore)
  (add-hook 'vc-before-checkin-hook 'bm-buffer-save)
#+END_SRC

=bm-restore-repository-on-load= は =bm= ロード前に設定する必要がある．

*** デフォルトではブックマークを永続化しない． =M-x bm-toggle-buffer-persistence= すること．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default bm-buffer-persistence nil)
#+END_SRC

*** マークを湘南色に．
#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-foreground 'bm-face "darkgreen")
  (set-face-background 'bm-face "darkorange")
#+END_SRC

*** =s-SPC= で現在行をマーク (=bm-toggle=).                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "s-SPC") 'bm-toggle)
#+END_SRC

*** =s-<= で前のマーク行に (=bm-previous=).                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "s-<") 'bm-previous)
#+END_SRC

*** =s->= で次のマーク行に (=bm-next=).                                 :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "s->") 'bm-next)
#+END_SRC

** sequencial-command.el                                   :elget:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(sequential-command sequential-command-config))

  (require 'sequential-command)
  (require 'sequential-command-config)
  (sequential-command-setup-keys)

#+END_SRC

** key-chord.el                                            :elget:rubikitch:

キーボード同時押し時のコマンドを指定する =key-chord-define= が使えるようになる．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'key-chord)

#+END_SRC

*** 全てのバッファで =key-chord-mode= を有効に．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'key-chord)
  (key-chord-mode 1)
#+END_SRC

*** 同時押し判定は 0.3 秒以内．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq key-chord-two-keys-delay 0.03)
#+END_SRC

** uniquify.el                                                   :rubikitch:

ファイル名が同じファイルを複数開いたときに，
バッファ名にディレクトリ名を含めて区別しやすくする．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
  (setq uniquify-ignore-buffers-re "*[^*]+*")
#+END_SRC名

** direx.el                                                           :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired)
  (require 'direx)
  (define-key dired-mode-map (kbd "b") 'direx:jump-to-directory)
  (define-key direx:direx-mode-map (kbd "b") 'dired-jump)

#+END_SRC

** dired-k                                                            :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired)
  (require 'dired-k)
  (define-key dired-mode-map (kbd "g") 'dired-k)
  (add-hook 'dired-initial-position-hook 'dired-k)
  (require 'direx-k)
  (define-key direx:direx-mode-map (kbd "K") 'direx-k)

#+END_SRC

** dired-x
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'windows-nt)
    (require 'dired-open)
    (setq dired-open-functions '(dired-open-guess-shell-alist))
    (let ((re (->> '("xlsx?" "pptx?" "docx?" "pdf" "jpg" "png" "bmp")
                (--map (concat "\\." it "\\'"))
                (-interpose "\\|")
                (apply 'concat))))
      (add-to-list 'dired-guess-shell-alist-user `(,re . ("explorer.exe")))))


#+END_SRC

** ido.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (ido-mode 1)
  (ido-everywhere 1)
  (setq ido-slow-ftp-hosts '("ssh"))
  (setq ido-create-new-buffer 'always)
  (setq ido-file-extensions-order '(".org" ".rb"))
  (setq ido-enable-flex-matching t)
#+END_SRC

*** =C-x C-f= で URL を開く (ido-use-url-at-pint).
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ido-use-url-at-point t)
#+END_SRC

** recentf-ext.el                                    :autoinstall:rubikitch:

最近使ったファイルを表示する =recentf.el= をもっと便利に．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'recentf-ext)

#+END_SRC

*** =recentf-exclude= に履歴に含めないファイルを設定．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'recentf-ext)
  (setq recentf-max-saved-items 3000)
  (setq recentf-exclude '("/TAGS$" "/tmp/$" "\.html$" "/work/$" "/\.emacs\.bmk$" "~$"))
  (setq tnoda/recentf-exclude-org 
        (list
         "org_archive$"
         "/mobileorg.org$"
         "/COMMIT_EDITMSG$"
         (expand-file-name "~/diary")
         (expand-file-name "~/org/main\.org")
         (expand-file-name "~/org/notes\.org")))
  (setq recentf-exclude (append recentf-exclude tnoda/recentf-exclude-org))
#+END_SRC

*** =recentf= でディレクトリを扱わない．

=recentf-ext.el= が

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'dired-mode-hook 'recentf-add-dired-directory)
#+END_SRC

しているので， =remove-hook= する．

#+BEGIN_SRC emacs-lisp :tangle yes
  (remove-hook 'dired-mode-hook 'recentf-add-dired-directory)
#+END_SRC

*** =C-@= で =recentf-open-files=                                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-@") 'recentf-open-files)
#+END_SRC

** bookmark.el                                                   :rubikitch:
ファイル内の特定位置をマークする．
+ ブックマークに変更があれば即保存 (bookmark-save-flag).
+ 最近使ったブックマークを燁に持ってくる (tnoda/bookmark-arrange).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq bookmark-save-flag 1)
  (setq bookmark-sort-flag nil)
  (defun tnoda/bookmark-arrange ()
    (let ((latest (bookmark-get-bookmark bookmark)))
      (setq bookmark-alist (cons latest (delq latest bookmark-alist))))
    (bookmark-save))
  (add-hook 'bookmark-after-jump-hook 'tnoda/bookmark-arrange)
#+END_SRC

** auto-save-buffers-enhanced.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'auto-save-buffers-enhanced)

  (auto-save-buffers-enhanced t)
  (setq auto-save-buffers-enhanced-interval 3)

#+END_SRC

** sense-region.el                                     :key:elget:rubikitch:

=C-SPC= 連打で選択範囲が広がっていく．マークとポイントが対角線の矩形を選択できる．


#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'sense-region)

  (require 'sense-region)
  (sense-region-on)

#+END_SRC

*** =C-SPC= 連打で =mark-word= できるので，=M-@= を無効にする．あまり使わないし．
- Note taken on [2012-01-18 Wed 10:21] \\
  =M-@= は特等席すぎるので，他で使うことにする．anything にしようかな．．．
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key (kbd "M-@"))
#+END_SRC

** cycle-buffer.el                                         :elget:rubikitch:
*** インストール

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'cycle-buffer)

#+END_SRC

*** =autoload= ではなく =require= する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cycle-buffer)
#+END_SRC

*** Mew の summary mode を対象外にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'cycle-buffer-filter
               '(not (string-match "^\\+.+" (buffer-name))))
#+END_SRC

*** gtd 関連ファイルを対象外にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'cycle-buffer-filter
               '(not (member (buffer-name) '("main.org" "notes.org" "diary"))))
#+END_SRC

*** Org の archive ファイルを対象外にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'cycle-buffer-filter
               '(not (string-match "_archive$" (buffer-name))))
#+END_SRC

*** =M-<= で前のバッファに移動 (=cycle-buffer-backward=).               :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-<")   'cycle-buffer-backward)
#+END_SRC

*** =M->= で次のバッファに移動 (=cycle-buffer=).                        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M->")   'cycle-buffer)
#+END_SRC

** popwin.el                                                          :cask:

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'popwin)
  (popwin-mode 1)

#+END_SRC

** point-undo.el                                           :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'point-undo)

#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'point-undo)
#+END_SRC

*** =C-,== でカーソルをコマンド実行前の位置に戻す (=point-undo=)        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-,") 'point-undo)
#+END_SRC

*** =C-.= でカーソルを次のコマンド実行位置に進める (=point-redo=)       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-.") 'point-redo)
#+END_SRC

** goto-chg.el                                             :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'goto-chg)

#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'goto-chg)
#+END_SRC

*** =C-<= でカーソルを最後の編集場所に戻す (=goto-last-change=).            :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-<") 'goto-last-change)
#+END_SRC

*** =C->= でカーソルを次の編集場所に進める (=goto-last-change-reverse=). :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C->") 'goto-last-change-reverse)
#+END_SRC

** eldoc-extension.el                                                :elget:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'eldoc-extension)

#+END_SRC

+ 設定
  - =emacs-lisp-mode= と =ielm-mode= で有効にする．
  - =lisp-interaction-mode= は Clojure にとっておく．
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'eldoc)
    (require 'eldoc-extension)
    (setq eldoc-idle-delay 0.1)
    (setq eldoc-echo-area-use-multiline-p t)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC

** tempbuf.el                                              :elget:rubikitch:

#+BEGIN_QUOTE
Tempbuf-mode is a minor mode that enables buffers to get
automatically deleted in the background when it can be deduced that
they are no longer of any use.

- tempbuf.el
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'tempbuf)

  (require 'tempbuf)
  (add-hook 'dired-mode-hook 'turn-on-tempbuf-mode)

#+END_SRC
    
** auto-complete.el                                        :elget:rubikitch:
*** Install via el-get.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'auto-complete-config)
  (ac-config-default)

#+END_SRC

*** 4 文字以上にならないと補完を開始しない (=ac-auto-start=).
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ac-auto-start 4)
#+END_SRC
  
** company-mode                                                       :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'company)

#+END_SRC

** col-highlight.el                                        :elget:rubikitch:

Do =M-x column-highlight=, to highlight the corrent column.

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(col-highlight vline))

  (require 'col-highlight)

#+END_SRC


** paredit.el                                                        :elget:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'paredit)

  (require 'paredit)
  (setq parens-require-spaces nil)
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'ielm-mode-hook 'enable-paredit-mode)

#+END_SRC


** rainbow-delimiters.el                                             :elget:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'rainbow-delimiters)

  (require 'rainbow-delimiters)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook 'rainbow-delimiters-mode)

#+END_SRC


** open-junk-file.el                                       :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'open-junk-file)

  (require 'open-junk-file)

#+END_SRC

*** Junk files will go to =~/.junk/=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq open-junk-file-format "~/.junk/%Y%m%d-%H%M%S.")

#+END_SRC

*** =C-x f= opens a new junk file.                                    :key:

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x f") 'open-junk-file)

#+END_SRC


** lispxmp.el                                              :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'lispxmp)

  (require 'lispxmp)
  (define-key emacs-lisp-mode-map (kbd "<S-f5>") 'lispxmp)

#+END_SRC


** color-moccur.el                                     :key:elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(color-moccur moccur-edit))

  (require 'moccur-edit)
  (setq moccur-split-edit t)
  (global-set-key (kbd "M-s o") 'occur-by-moccur)
  (global-set-key (kbd "M-s O") 'moccur)
#+END_SRC


** text-adjust.el                                          :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'text-adjust)
#+END_SRC

*** =kinsoku-ascii= がいつのまにか =kinsoku.el= から無くなっているので定義．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'text-adjust)
  (defvar kinsoku-ascii t "Do kinsoku-shori for ASCII.")
#+END_SRC

*** =M-q= で =text-adjust-*= する．=C-u M-q= で =*-buffer=. =C-u C-u M-q= で =fill= だけ． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/text-adjust (arg)
    (interactive "p")
    (case arg
      (16
       (call-interactively 'text-adjust-fill))
      (4
       (call-interactively 'text-adjust-codecheck-buffer)
       (call-interactively 'text-adjust-hankaku-buffer)
       (call-interactively 'text-adjust-space-buffer)
       (call-interactively 'text-adjust-fill-buffer))
      (t
       (call-interactively 'text-adjust-codecheck)
       (call-interactively 'text-adjust-hankaku)
       (call-interactively 'text-adjust-space)
       (call-interactively 'text-adjust-fill))))
  (global-set-key (kbd "M-q") 'tnoda/text-adjust)
#+END_SRC

*** 左マージンを考慮する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq adaptive-fill-regexp "[ \t]*")
  (setq adaptive-fill-mode t)
#+END_SRC

*** ？と！とを半角へ変換しないようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq text-adjust-hankaku-except "？！＠ー〜、，。．")
#+END_SRC

** igrep.el                                                :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (eq system-type 'windows-nt)
    (el-get 'sync 'igrep)

    (require 'igrep))

#+END_SRC

** grep-edit.el                                            :elget:rubikitch:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'grep-edit)

  (require 'grep-edit)

#+END_SRC

*** =*grep*= で =C-c C-e= すると変更を反映．                          :key:
*** =*grep*= で =C-c C-r= するとリージョンの変更を破棄．              :key:
*** =*grep*= で =C-c C-u= するとバッファへの変更を破棄．              :key:

** hideshow-org.el                                                   :elget:

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'hideshow-org)

  (require 'hideshow-org)

#+END_SRC

*** =tnoda/hs-org/minor-mode-activate=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'hideshow-org)
  (defun tnoda/hs-org/minor-mode-activate ()
    "Activate hideshow-org"
    (interactive)
    (hs-org/minor-mode 1)
    (raise-minor-mode-map-alist 'hs-org/minor-mode))
#+END_SRC

*** 折りたたみ部分をハイライトする =tnoda/highlight-overlay=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/highlight-overlay (ov)
    "Self-explanatory!"
    (overlay-put ov 'display (propertize (format "...") 'face 'highlight)))
  
  (setq hs-set-up-overlay 'tnoda/highlight-overlay)
#+END_SRC

** highlight-symbol.el                                               :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'highlight-symbol)
  (require 'highlight-symbol)
  (define-prefix-command 'highlight-symbol-mode-map)
  (global-set-key (kbd "C-c h") 'highlight-symbol-mode-map)
  (smartrep-define-key
      global-map "C-c h" '(("h" . highlight-symbol-at-point)
                           ("n" . highlight-symbol-next)
                           ("p" . highlight-symbol-prev)
                           ("l" . hi-lock-mode)))
#+END_SRC

** smartparens                                                       :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'smartparens)
  (sp-use-paredit-bindings)

#+END_SRC

** pretty-mode.el                                                    :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'pretty-mode)
#+END_SRC

** flymake                                                           :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'flymake)
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'flycheck)
#+END_SRC

** YASnippet                                                          :cask:

Use YASnippet as a non-global minor mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'yasnippet)
  (yas-reload-all)

#+END_SRC

** visual-regexp                                                      :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'visual-regexp)
  (global-set-key (kbd "C-M-%") 'vr/query-replace)

#+END_SRC

** guide-key                                                          :cask:

=guide-key= configuration, regrieved from
http://rubikitch.com/f/140830063637.guide-key.el
on Sep. 2, 2014.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'guide-key)

  ;;; guilde-keyを発動させるプレフィクスキー
  (setq guide-key/guide-key-sequence
        '("C-x r" "C-x 4"                 ;global
          ;; org-modeではC-c C-xも対象にする
          (org-mode "C-c C-x")
          ;; outline-minor-modeではC-c @も対象にする
          (outline-minor-mode "C-c @")))

  ;;; コマンド名にこれらが含まれている場合はハイライトされる
  (setq guide-key/highlight-command-regexp "rectangle\\|register\\|org-clock")

  ;;; 1秒後にポップアップされる(デフォルト)
  ;;; つまり1秒以内に操作すればポップアップされずに実行される
  (setq guide-key/idle-delay 1.0)

  ;;; 下部にキー一覧を表示させる(デフォルトはright)
  (setq guide-key/popup-window-position 'bottom)

  ;;; 文字の大きさを変更する(正の数で大きく、負の数で小さく)
  (setq guide-key/text-scale-amount 0)

  ;;; 有効にする
  (guide-key-mode 1)

#+END_SRC

** ace-isearch                                                        :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-ace-isearch-mode 1)

#+END_SRC

* Eshell
** Plan 9 Smart Shell
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
#+END_SRC

** Bind =cycle-buffer= to =C-z= in eshell-mode.                    :key:

Pressing =C-z= toggles between an eshell buffer and another.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/eshell-toggle-key ()
    (define-key eshell-mode-map (kbd "C-z") 'cycle-buffer))
  (add-hook 'eshell-mode-hook 'tnoda/eshell-toggle-key)
#+END_SRC

** プロンプトの色を変える．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'em-prompt)
  (set-face-foreground 'eshell-prompt "cyan")
#+END_SRC

** プロンプトに Git のブランチ名を表示．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'vc-git)
  (defun tnoda/eshell-git-branch ()
    "Return the branch name surrounded by square brackets, 
  or nil if the current directory is not in a Git repsitory."
    (let ((branch (vc-git-working-revision (eshell/pwd))))
      (when (< 0 (length branch))
        (format "[%s]" branch))))
  
  (defun tnoda/eshell-prompt-function ()
    (mapconcat 'identity
               (delq nil (list
                          (abbreviate-file-name (eshell/pwd))
                          (tnoda/eshell-git-branch)
                          (if (= 0 (user-uid))
                              "# "
                            "$ ")))
               " "))
  
  (setq eshell-prompt-function 'tnoda/eshell-prompt-function)
#+END_SRC

* Shell-mode
** Suppress echo-backs
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'shell-mode-hook
            (lambda ()
              (setq comint-process-echoes t)))
#+END_SRC

* Pcomplete
** Git ブランチのリストを返す関数 =tnoda/git-branches=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-branches ()
      (split-string (shell-command-to-string "git branch | sed -e 's/[ *]*//'")))
#+END_SRC

** Git でステータス変更があったファイルのリストを返す関数 =tnoda/git-modified-files=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-modified-files ()
      (split-string (shell-command-to-string "git status -s | sed -e 's/^.. *//'")))
#+END_SRC

** =m= (=git merge= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/m ()
    "Completion for `m' (`git merge')"
    (pcomplete-here* (tnoda/git-branches)))
#+END_SRC

** =co= (=git checkout= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/co ()
    "Completion for `co' (`git checkout')"
    (pcomplete-here* (tnoda/git-branches)))
#+END_SRC

** =bd= (=git branch -d= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/bd ()
    "Completion for `bd' (`git branch -d')"
    (pcomplete-here* (tnoda/git-branches)))
#+END_SRC

** =a= (=git add -p= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/a ()
    "Completion for `a' (`git add -p')"
    (while (pcomplete-here (tnoda/git-modified-files))))
#+END_SRC

** =git add= と =git rm= とをを補完する．

=git add= は新規ファイルの追加にのみ使用する．既存ファイルのステージングは =a=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-untracked-files ()
    (split-string (shell-command-to-string "git status -s -u | sed -e 's/^...//'")))
  
  (defconst pcmpl-git-commands
    '("add" "bisect" "branch" "checkout" "clone"
      "commit" "diff" "fetch" "grep"
      "init" "log" "merge" "mv" "pull" "push" "rebase"
      "reset" "rm" "show" "status" "tag" )
    "List of `git' commands")
  
  (defun pcomplete/git ()
    "Completion for `git'"
    ;; Completion for the command argument.
    (pcomplete-here* pcmpl-git-commands)  
    ;; complete files/dirs forever if the command is `add' or `rm'
    (cond
     ((pcomplete-match (regexp-opt '("add") ))
      (while (pcomplete-here (tnoda/git-untracked-files))))
     ((pcomplete-match (regexp-opt '("rm" "reset" "mv")) 1)
      (while (pcomplete-here (pcomplete-entries))))))
#+END_SRC

** =d= (=git diff= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-unstaged-files ()
    "Return a list of files which are modified but unstaged."
    (split-string (shell-command-to-string "git status -s | egrep '^.M' | sed -e 's/^.M //'")))
  
  (defun pcomplete/d ()
    "Completion for `d' (`git diff')."
    (while (pcomplete-here (tnoda/git-unstaged-files))))
#+END_SRC

** =dc= (=git diff --cached= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-staged-files ()
    "Return a list of staged files."
    (split-string (shell-command-to-string "git status -s | egrep '^M' | sed -e 's/^M.//'")))
  
  (defun pcomplete/dc ()
    "Completion for `dc' (`git diff')."
    (while (pcomplete-here (tnoda/git-staged-files))))
#+END_SRC

* SKK
** インストール
#+BEGIN_SRC sh :tangle install-skk.sh :var prefix=tnoda-dotfiles-dir elisp_dir=tnoda-elisp-dir info_dir=tnoda-info-dir emacs=emacs-app
  cd src
  curl http://www.ring.gr.jp/archives/elisp/skk/maintrunk/ddskk-15.1.tar.gz | tar zxf -
  cd ddskk-15.1
  echo "(setq PREFIX \"${prefix}\")
  (setq SKK_DATADIR \"${prefix}/share/skk\")
  (setq SKK_INFODIR \"${info_dir}\")
  (setq SKK_LISPDIR \"${elisp_dir}/skk\")
  (setq SKK_SET_JISYO t)" > SKK-CFG
  make EMACS=$emacs install
#+END_SRC

** =C-x C-j= で =skk-mode=.                                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'skk-autoloads)
  (define-key ctl-x-map (kbd "C-j") 'skk-mode)
#+END_SRC

** =C-\= でも =skk-mode=.                                              :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-\\") 'skk-mode)
#+END_SRC

** =~/.skk.el= の設定
+ =skk-large-jisyo=
+ =skk-server-host=
+ =skk-server-portnum=
+ =skk-dcomp-activate=
+ =skk-today= / =skk-clock= で西暦表示 (=skk-data-ad=).
+ 読点句点の代わりに，「，」「．」を使う (=skk-rom-kana-rule-list=).
+ アノテーションを表示する (=skk-show-annotation=).
+ 見出し語と送り仮名が一致した候補を優先表示 (=skk-henkan-strict-okuri-precedence=).
+ 半角カナの入力規則を有効に (=skk-use-jisx0201-input-method=).

* Migemo

+ cmigemo を https://gist.github.com/1824249 の formula で =brew install= する．
+ migemo.el のインストールと設定は，http://d.hatena.ne.jp/samurai20000/20100907/1283791433 を参考にする．

** インストール
#+BEGIN_SRC emacs-lisp :tangle no
  (auto-install-from-url "https://raw.github.com/gist/457761/539882a79ec11bc9b6e1ac417cdafe0e198e245f/migemo.el")
#+END_SRC

** C/Migemo を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'migemo)
  (setq migemo-command "cmigemo")
  (setq migemo-options '("-q" "--emacs"))
  (setq migemo-dictionary "/opt/homebrew/Cellar/cmigemo/20110227/share/migemo/utf-8/migemo-dict")
  (setq migemo-user-dictionary nil)
  (setq migemo-regex-dictionary nil)
  (setq migemo-coding-system 'utf-8-unix)
  (load-library "migemo")
  (migemo-init)
  (setq search-whitespace-regexp nil)
#+END_SRC

* Mail/News/WWW
** Install APEL using el-get.
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'apel)
#+END_SRC

** FLIM/SEMI のインストール．
:PROPERTIES:
:var: src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app prefix=tnoda-dotfiles-dir
:END:

+ FLIM
  #+BEGIN_SRC sh :tangle install-flim.sh
    cd src
    curl http://www.ring.gr.jp/archives/elisp/flim/flim-1.14/flim-1.14.9.tar.gz | tar zxf -
    cd flim-1.14.9
    echo "(add-to-list 'load-path \"${elisp_dir}/apel\")
    (add-to-list 'load-path \"${elisp_dir}/emu\")
    (require 'install)
    (defvar default-load-path load-path)
    (add-latest-path \"custom\")
    (add-path default-directory)
    (setq PREFIX \"${prefix}\")
    (setq FLIM_PREFIX \"flim\")
    (setq LISPDIR \"${elisp_dir}\")
    (setq FLIM_DIR (expand-file-name FLIM_PREFIX LISPDIR))
    (setq VERSION_SPECIFIC_LISPDIR \"${elisp_dir}\")" > FLIM-CFG
    make EMACS=$emacs install
  #+END_SRC

+ SEMI
  #+BEGIN_SRC sh :tangle install-semi.sh
    cd src
    curl http://www.ring.gr.jp/archives/elisp/semi/semi-1.14-for-flim-1.14/semi-1.14.6.tar.gz | tar zxf -
    cd semi-1.14.6
    echo "(add-to-list 'load-path \"${elisp_dir}/apel\")
    (add-to-list 'load-path \"${elisp_dir}/emu\")
    (add-to-list 'load-path \"${elisp_dir}/flim\")
    (add-to-list 'load-path (expand-file-name \".\"))
    (require 'install)
    (defvar default-load-path load-path)
    (add-latest-path \"custom\")
    (add-path default-directory)
    (add-path \"bitmap-mule\")
    (add-path \"flim\")
    (setq PREFIX \"${prefix}\")
    (setq LISPDIR \"${elisp_dir}\")
    (setq METHOD_DIR \"${prefix}/share/semi\")
    (setq SEMI_KERNEL_DIR \"${elisp_dir}/semi\")
    (setq SETUP_FILE_DIR SEMI_KERNEL_DIR)
    (setq METHOD_SRC_DIR \"methods\")
    (setq METHODS
        '(\"tm-au\" \"tm-file\" \"tm-html\" \"tm-image\" \"tm-mpeg\"
          \"tm-plain\" \"tm-ps\"
          \"tmdecode\"))" > SEMI-CFG
    make EMACS=$emacs install
  #+END_SRC

** Wanderlust                                                          :cvs:
+ インストール
  #+BEGIN_SRC sh :tangle install-wl.sh :var src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app info_dir=tnoda-info-dir prefix=tnoda-dotfiles-dir
    cd $src_dir
    expect -c "set timeout 10
    spawn cvs -d :pserver:anonymous@cvs.m17n.org:/cvs/root login
    expect \"CVS password:\" {
      send \"\n\"
    }
    "
    cvs -d :pserver:anonymous@cvs.m17n.org:/cvs/root checkout wanderlust
    cd wanderlust
    echo "(setq load-path (append
                     (list \"$elisp_dir/apel\"
                           \"$elisp_dir/emu\"
                           \"$elisp_dir/flim\"
                           \"$elisp_dir/semi\")
                     load-path))
    (setq wl-install-utils t)
    (setq wl-info-lang \"ja\")
    " > WL-CFG
    make EMACS=$emacs LISPDIR=$elisp_dir install PIXMAPDIR=$prefix/share/wl
    make EMACS=$emacs LISPDIR=$elisp_dir install PIXMAPDIR=$prefix/share/wl
    make EMACS=$emacs info
    make EMACS=$emacs INFODIR=$info_dir install-info
  #+END_SRC

+ 設定
  #+BEGIN_SRC emacs-lisp :tangle yes
    (autoload 'wl "wl" "Wanderlust" t)
    (autoload 'wl-other-frame "wl" "Wanderlust on new frame." t)
    (autoload 'wl-draft "wl-draft" "Write draft with Wanderlust." t)
  #+END_SRC

+ =.wl.el= の設定
  - =wl-init-hook= と =wl-exit-hook= で，ssh port forwarding を開始・終了する
    設定を追加している．

** emacs-w3m                                                          :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (require 'w3m)
    (add-hook 'w3m-mode-hook 'tnoda/increase-line-spacing)
    (when (fboundp 'cask-resource-path)
      (defun tnoda/add-cask-w3m-to-info-directory-list ()
        (add-to-list 'Info-directory-list
                     (cask-resource-path "org-plus-contrib")))
      (add-hook 'Info-mode-hook
                'tnoda/add-cask-w3m-to-info-directory-list)))

#+END_SRC

** Mew
*** インストール
#+BEGIN_SRC sh :tangle install-mew.sh :var prefix=tnoda-dotfiles-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app
  cd src
  curl http://www.mew.org/Release/mew-6.6.tar.gz | tar zxf -
  cd mew-6.6
  ./configure --prefix=${prefix} \
          --with-elispdir=${elisp_dir}/mew \
          --with-emacs=$emacs --with-etcdir=${prefix}/share/mew
  make
  make install
  make install-info
  make install-jinfo
#+END_SRC

*** Windows
#+begin_src emacs-lisp :tangle yes
  (when (eq system-type 'windows-nt)
    (defconst tnoda/mew-windows-dir
      (expand-file-name "mew-6.6" tnoda/src-dir))
    (add-to-list 'load-path tnoda/mew-windows-dir))

#+end_src

*** 最小限の設定

=mail-user-agent= は =simple.el= で，=define-mail-user-agent= は =subr.el= で，それぞれ定義されている．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'mew)
  (require 'simple)
  (setq mail-user-agent 'mew-user-agent)
  (define-mail-user-agent
    'mew-user-agent
    'mew-user-agent-compose
    'mew-draft-send-message
    'mew-draft-kill
    'mew-send-hook)
#+END_SRC

*** 起動時にくるくる回らない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-demo nil)
#+END_SRC

*** 起動時にメールを取得しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-auto-get nil)
#+END_SRC

*** 引用ラベルを簡潔にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-cite-fields '("From:"))
  (setq mew-cite-format "%s writes:\n")
#+END_SRC

*** Summary モードでは本文は不要なので，その分 subject を広くとる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-summary-form '(type (5 date) " " (18 from) " " t (0 subj)))
#+END_SRC

*** 転送時に =Received:= と =Return-Path:= をヘッダから削る．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-field-delete-for-forwarding '("Received:" "Return-Path:"))
#+END_SRC

*** GnuPG を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-prog-pgp "gpg")
#+END_SRC

*** 証明書の検証に失敗したり，証明書が無かったりする場合には SSL/TLS 接続しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-ssl-verify-level 2)
#+END_SRC

*** 添付ファイルのデフォルトの保存先は =~/tmp=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-save-dir "~/tmp/")
#+END_SRC

*** 用事が済んだらすぐに SSH 接続を切る．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-ssh-keep-connection nil)
#+END_SRC

*** マスターパスワードを使う．PGP を使ってパスワードを保存．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-use-master-passwd t)
#+END_SRC

*** Hyper Estraier で検索する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-search-method 'est)
#+END_SRC

*** =draft= と =message= とでは行間を広く表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'mew-draft-mode-hook 'tnoda/increase-line-spacing)
  (add-hook 'mew-message-mode-hook 'tnoda/increase-line-spacing)
#+END_SRC

*** =draft-mode= で Org のテーブル記法と箇条書きを有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'mew-draft-mode-hook 'turn-on-orgstruct++)
  (add-hook 'mew-draft-mode-hook 'turn-on-orgtbl)
#+END_SRC

*** =.mew.el= の設定．
+ =mew-refile-guess-alist=
+ =mew-config-alist=

*** test/html を =message= バッファに表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (boundp 'w3m)
    (require 'mew-w3m)
    (setq mew-use-text/html t))

#+END_SRC

* Lang

** Emacs Lisp

*** elisp-slime-nav                                                  :cask:

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'elisp-slime-nav)
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'turn-on-elisp-slime-nav-mode))

#+END_SRC

** Clojure                                                       :marmalade:
*** Leiningen has been installed in =~/lein=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path (expand-file-name ".lein" "~/"))
#+END_SRC

*** clojure-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'clojure-mode)
  (define-key clojure-mode-map (kbd "<f5>") 'nrepl-ritz-jack-in)
  (define-key clojure-mode-map (kbd "C-c t") nil)

  (defun tnoda/clojure-mode-hook ()
    (enable-paredit-mode)
    (rainbow-delimiters-mode 1)
    (subword-mode 1)
    (yas-minor-mode)
    (setq show-trailing-whitespace t)
    (setq buffer-save-without-query t))

  (add-hook 'clojure-mode-hook 'tnoda/clojure-mode-hook)

#+END_SRC

**** Yasnippet helper functions.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/lein-root (&optional dir)
    (interactive)
    (setq dir (or dir default-directory))
    (if (file-exists-p (expand-file-name "project.clj" dir))
        (expand-file-name dir)
      (let ((new-dir (expand-file-name (file-name-as-directory "..") dir)))
        (unless (string-match "\\(^[[:alpha:]]:/$\\|^/[^\/]+:/?$\\|^/$\\)" dir)
          (tnoda/lein-root new-dir)))))
  
  (defun tnoda/lein-guess-namespace ()
    "Return the clojure namespace associated with the current buffer."
    (interactive)
    (replace-regexp-in-string "_" "-" (replace-regexp-in-string "/" "." (substring (file-name-sans-extension buffer-file-name)
                                                                                   (+ 4 (length (tnoda/lein-root)))))))
#+END_SRC

*** CIDER
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cider)

  (defun tnoda/cider-repl-mode-hook ()
    (enable-paredit-mode)
    (rainbow-delimiters-mode 1)
    (subword-mode 1)
    (font-lock-mode 1))

  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
  (add-hook 'cider-repl-mode-hook 'tnoda/cider-repl-mode-hook)

#+END_SRC

*** company-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'cider-mode-hook 'company-mode)
  (add-hook 'cider-repl-mode-hook 'company-mode)

#+END_SRC

*** Inferior Lisp Mode

**** Enable paredit-mode in inferior-lisp-mode.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'inferior-lisp-mode-hook 'enable-paredit-mode)
#+END_SRC

**** =M-x run-lisp= で Clojure の REPL.                          :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inferior-lisp-program (expand-file-name "~/.lein/lein repl"))
#+END_SRC

**** =inferior-lisp-mode= で paredit に =[]= と ={}= も括弧扱いさせる．
via http://stackoverflow.com/questions/8598116/paredit-curly-brace-matching-in-swank-clojure-repl

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/curly-brace-matching-fix ()
    (modify-syntax-entry ?\{ "(}")
    (modify-syntax-entry ?\} "){")
    (modify-syntax-entry ?\[ "(]")
    (define-key inferior-lisp-mode-map
      (kbd "DEL") 'paredit-backward-delete)
    (define-key inferior-lisp-mode-map
      (kbd "{") 'paredit-open-curly)
    (define-key inferior-lisp-mode-map
      (kbd "}") 'paredit-close-curly)
    (modify-syntax-entry ?\] ")[")
    (modify-syntax-entry ?~ "'   ")
    (modify-syntax-entry ?, "    ")
    (modify-syntax-entry ?^ "'")
    (modify-syntax-entry ?= "'"))
  
  (add-hook 'inferior-lisp-mode-hook 'tnoda/curly-brace-matching-fix)
#+END_SRC

** Ruby

*** Install elisps using el-get.
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(ruby-mode inf-ruby yari))
  (require 'ruby-mode)
  (require 'inf-ruby)
#+END_SRC

*** smartparens-ruby
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'smartparens-ruby)
  (add-hook 'ruby-mode-hook 'smartparens-strict-mode)

#+END_SRC

*** =~/.rbenv/shims= を =exec-path= に追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path (expand-file-name "~/.rbenv/shims"))
#+END_SRC

*** =ruby-mode=
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-mode-hook ()
    (electric-pair-mode -1)
    (electric-indent-mode 1)
    (electric-layout-mode 1)
    (subword-mode 1)
    (setq show-trailing-whitespace t)
    (outline-minor-mode 1)
    (setq outline-regexp " *\\(def \\|class\\|module\\|describe \\|it \\)"))

  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Vagrantfile$" . ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))
  (setq ruby-use-encoding-map nil)
  (setq ruby-deep-indent-paren-style nil)
  (setq ruby-insert-encoding-magic-comment nil)
  (add-hook 'ruby-mode-hook 'tnoda/ruby-mode-hook)
#+END_SRC

*** Bind =ruby-interpolate= to =#=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ruby-interpolate ()
    "In a double quoted string, interpolate."
    (interactive)
    (insert "#")
    (when (and
           (looking-back "\".*")
           (looking-at ".*\""))
      (insert "{}")
      (backward-char 1)))
  
  (define-key ruby-mode-map (kbd "#") 'ruby-interpolate)
#+END_SRC


*** =inf-ruby=

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'inf-ruby-implementations '("pry" . "pry -Ilib"))
  (setq inf-ruby-default-implementation
        (cond ((eq system-type 'darwin)
               (progn
                 (setq inf-ruby-first-prompt-pattern
                       "^\\[[0-9]+\\] pry\\((.*)\\)> *")
                 (setq inf-ruby-prompt-pattern
                       "^\\[[0-9]+\\] pry\\((.*)\\)[>*\"'] *")
                 "pry"))
              (t "ruby")))

#+END_SRC

*** =C-m= を =reindent-then-newline-and-indent= に設定．              :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key ruby-mode-map (kbd "RET") 'reindent-then-newline-and-indent)
#+END_SRC

*** =ruby-mode= の =C-M-a= で =tnoda/ruby-beginning-of-defun=.        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-beginning-of-defun ()
    "Move backward to the beginning of the current defun"
    (interactive)
    (and (re-search-backward "\\bdef\\b" nil t)
         (beginning-of-line)))
  
  (define-key ruby-mode-map (kbd "C-M-a") 'tnoda/ruby-beginning-of-defun)
#+END_SRC

*** =ruby-mode= の =C-M-e= で =tnoda/ruby-end-of-defun=.              :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-beginning-of-defun-indent-level ()
    (save-excursion
      (end-of-line)
      (when (re-search-backward "^\\( *\\)def\\b" nil t)
        (length (match-string 1)))))
  
  (defun tnoda/ruby-end-of-defun ()
    "Move forward to the end of the current defun"
    (interactive)
    (let ((current-indent-level (tnoda/ruby-beginning-of-defun-indent-level)))
      (and current-indent-level
           (re-search-forward (concat "^"
                                      (make-string current-indent-level 32)
                                      "end\\b")
                              nil t)
           (forward-line 1))))
  
  (define-key ruby-mode-map (kbd "C-M-e") 'tnoda/ruby-end-of-defun)
#+END_SRC

*** =ruby-mode= の =C-M-h= で =tnoda/ruby-mark-defun=.                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-mark-defun ()
    "Put mark at the end of the current defun, point at the beginning"
    (interactive)
    (flet ((ruby-beginning-of-defun (&optional arg) (tnoda/ruby-beginning-of-defun))
           (ruby-end-of-defun (&optional arg) (tnoda/ruby-end-of-defun)))
      (call-interactively 'mark-defun)))
  
  (define-key ruby-mode-map (kbd "C-M-h") 'tnoda/ruby-mark-defun)
#+END_SRC

*** =align-rules-list=. =M-x align= でコンマ区切りとハッシュを整列． :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'align)
  (add-to-list 'align-rules-list
               '(ruby-comma-delimiter
                 (regexp . ",\\(\\s-*\\)[^# \t\n]")
                 (repeat . t)
                 (modes  . '(ruby-mode))))
  (add-to-list 'align-rules-list
               '(ruby-hash-literal
                 (regexp . "\\(\\s-*\\)=>\\s-*[^# \t\n]")
                 (repeat . t)
                 (modes  . '(ruby-mode))))
#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'ruby-mode-hook 'tnoda/turn-on-flycheck-mode)

#+END_SRC

*** Rsense

**** Install via Homebrew

#+BEGIN_EXAMPLE
  ~ % brew install rsense
  ==> Downloading http://cx4a.org/pub/rsense/rsense-0.3.tar.bz2
  ################################################################### 100.0%
  ==> Caveats
  If this is your first install, create default config file:
      ruby /opt/homebrew/Cellar/rsense/0.3/libexec/etc/config.rb > ~/.rsense
  
  You will also need to setup Emacs and/or Vim to use Rsense. Please
  refer to the User Manual: http://cx4a.org/software/rsense/manual.html
  ==> Summary
  🍺  /opt/homebrew/Cellar/rsense/0.3: 115 files, 9.9M, built in 36 seconds
  ~ % ruby /opt/homebrew/Cellar/rsense/0.3/libexec/etc/config.rb > ~/.rsense
#+END_EXAMPLE

**** Configuration

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (defconst rsense-home "/opt/homebrew/Cellar/rsense/0.3/libexec")
    (add-to-list 'load-path (expand-file-name "etc" rsense-home))
    (require 'rsense)

  ;;; Ruby Reference Manual
    (setq rsense-rurema-home "/Users/tnoda/.rbenv/shims")
    (setq rsense-rurema-refe "refe")

  ;;; C-c .
    (define-prefix-command 'tnoda/rsense-map)
    (define-key ruby-mode-map (kbd "C-c .") 'tnoda/rsense-map)
    (define-key tnoda/rsense-map (kbd ".") 'ac-complete-rsense)
    (define-key tnoda/rsense-map (kbd "t") 'rsense-type-help)
    (define-key tnoda/rsense-map (kbd "j") 'rsense-jump-to-definition)
    (define-key tnoda/rsense-map (kbd "w") 'rsense-where-is)
    (define-key tnoda/rsense-map (kbd "v") 'rsense-version)
    (define-key tnoda/rsense-map (kbd "o") 'rsense-open-project)
    (define-key tnoda/rsense-map (kbd "c") 'rsense-close-project)
    (define-key tnoda/rsense-map (kbd "l") 'rsense-clear)
    (define-key tnoda/rsense-map (kbd "x") 'rsense-exit)

  ;;; Start completion automatically after inserting . or ::.
    (defun tnoda/ac-complete-rsense-automatically ()
      (add-to-list 'ac-sources 'ac-source-rsense-method)
      (add-to-list 'ac-sources 'ac-source-rsense-constant))
    (add-hook 'ruby-mode-hook 'tnoda/ac-complete-rsense-automatically))

#+END_SRC

** Markdown                                                    :autoinstall:

#+begin_src emacs-lisp
  (require 'markdown-mode)

#+end_src


*** Use the =markdown= command located in =/opt/homebew/bin=
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/markdown-custom ()
    "markdown-mode-hook"
    (setq markdown-command (expand-file-name "markdown" "/opt/homebrew/bin")))
  (add-hook 'markdown-mode-hook 'tnoda/markdown-custom)
#+END_SRC

*** =.text= なファイルは =markdown-mode= で開く．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.text" . markdown-mode))
#+END_SRC

*** =.md= なファイルは =gfm-mode= で開く．

=gfm-mode= なファイルには，特製の =bin/gfm= を使う．

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.md" . gfm-mode))
  (defun tnoda/gfm-custom ()
    "gfm-mode-hook"
    (setq markdown-command (expand-file-name "gfm" tnoda/bin-dir)))
  (add-hook 'gfm-mode-hook 'tnoda/gfm-custom)
#+END_SRC

*** =<S-tab>= で =markdown-shifttab=.                                   :key:

デフォルトでは =markdown-shifttab= が =<S-iso-lefttab>= に割り当てられ
ているため．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/markdown-shifttab-fix ()
    "Bind `markdown-shifttab' to <S-tab>"
    (local-set-key (kbd "<S-tab>") 'markdown-shifttab))
  
  (add-hook 'markdown-mode-hook 'tnoda/markdown-shifttab-fix)
  (add-hook 'gfm-mode-hook 'tnoda/markdown-shifttab-fix)
#+END_SRC

** Java

*** Set =JAVA_HOME= using =java_home=
#+BEGIN_SRC emacs-lisp :tangle yes
  (setenv "JAVA_HOME"
          (let ((ret (shell-command-to-string "/usr/libexec/java_home")))
            (substring ret 0 (1- (length ret)))))

#+END_SRC

*** ajc-java-complete
#+BEGIN_SRC sh :tangle setup-tags-for-ajc.sh :var prefix=el-get-dir
  cd ${prefix}/ajc-java-complete
  javac Tags.java
  java -cp ~/clojure.jar:/System/Library/Frameworks/JavaVM.framework/Classes/classes.jar:. Tags
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'ajc-java-complete)
  (require 'ajc-java-complete-config)
  
  (eval-after-load "auto-complete"
    '(add-to-list 'ac-modes 'java-mode))
  
  (defun tnoda/enable-ajc-java-complete-mode
    ()
    (ajc-java-complete-mode 1))
  
  (add-hook 'java-mode-hook 'tnoda/enable-ajc-java-complete-mode)
#+END_SRC

*** Leiningen support
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/java-mode-hook ()
    (set (make-local-variable 'compile-command) "lein javac")
    (set (make-local-variable 'compilation-read-command) nil)
    (define-key java-mode-map (kbd "C-c C-c") 'compile))
  
  (add-hook 'java-mode-hook 'tnoda/java-mode-hook)
#+END_SRC

*** flymake
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'flymake)
  (add-hook 'java-mode-hook 'flymake-mode-on)
  
  (defun tnoda/java-flymake-init ()
    (list "javac" (list (flymake-init-create-temp-buffer-copy
                         'flymake-create-temp-with-folder-structure))))
  
  (add-to-list 'flymake-allowed-file-name-masks
               '("\\.java$" tnoda/java-flymake-init flymake-simple-cleanup))
#+END_SRC

** Scala

*** scala-mode2                                                      :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'scala-mode2)
  (setq scala-indent:default-run-on-strategy 0)
  (setq scala-indent:indent-value-expression nil)
  (setq scala-indent:align-parameters t)
  (setq scala-indent:align-forms t)

  (require 'smartparens-config)

  (defun tnoda/scala-mode-hook ()
    (tnoda/increase-line-spacing)
    (subword-mode 1)
    (electric-pair-mode -1)
    (turn-on-smartparens-strict-mode)
    (setq imenu-generic-expression
          '((nil "^ *\\(abstract \\|case \\)?\\(class\\|object\\) \\w+\\( extends [^\\{}]+\\)?.*" 0)
            (nil "^ *\\(override \\|implicit \\)?def .*" 0)
            (nil "\\( *trait .*\\){" 1))))

  (add-hook 'scala-mode-hook 'tnoda/scala-mode-hook)
  (add-hook 'scala-mode-hook 'yas-minor-mode-on)

#+END_SRC

*** ENSIME                                                           :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ensime)
  (setq ensime-sbt-perform-on-save nil)
  (setq ensime-scaladoc-stdlib-url-base
        (concat "file://"
                (expand-file-name "Documents/Scala/scala-docs-2.11.2/api/scala-library/"
                                  (getenv "HOME"))))
  (setq ensime-javadoc-stdlib-url-base
        (concat "file://"
                (expand-file-name "Documents/Java/jdk-8u25-docs/api/"
                                  (getenv "HOME"))))
  (add-hook 'scala-mode-hook 'ensime-scala-mode-hook)

#+END_SRC

*** pretty-mode.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'scala-mode-hook 'turn-on-pretty-mode)
  (pretty-add-keywords 'scala-mode '(("=>" . (string-to-char "⇒"))
                                     ("<=" . (string-to-char "≤"))
                                     (">=" . (string-to-char "≥"))
                                     ("!=" . (string-to-char "≠"))
                                     ("->" . (string-to-char "→"))
                                     ("<-" . (string-to-char "←"))
                                     ("&&" . (string-to-char "∧"))
                                     ("||" . (string-to-char "∨"))
                                     ("\\<compose\\>" . (string-to-char "◦") )))
  (font-lock-add-keywords
   'scala-mode
   '(("\\(!\\)[^=]" (0 (prog1 ()
                     (compose-region (match-beginning 1)
                                     (match-end 1)
                                     (string-to-char "¬")))))))
#+END_SRC

** Graphviz
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'graphviz-dot-mode)
  (require 'graphviz-dot-mode)
  (setq graphviz-dot-indent-width 2)
#+END_SRC

** Python

*** pdb
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gud-pdb-command-name "pdb.sh")

#+END_SRC

*** Jedi.el
#+BEGIN_SRC emacs-lisp :tangle no
  (require 'python-environment)
  (setq python-environment-virtualenv '("pyvenv" "--system-site-packages"))
  (require 'auto-complete-config)
  (require 'python)
  (require 'jedi)
  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:complete-on-dot t)

#+END_SRC

*** Flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'flycheck)
  (require 'python)

  (defun tnoda/turn-on-flycheck-mode ()
    (flycheck-mode 1))
  (add-hook 'python-mode-hook 'tnoda/turn-on-flycheck-mode)

#+END_SRC

*** Smartparens
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'python)
  (add-hook 'python-mode-hook 'turn-on-smartparens-strict-mode)

#+END_SRC

** Golang

*** go-mode/gocode
#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar tnoda/gopath (expand-file-name "go" (getenv "HOME")))
  (defvar tnoda/gopath-bin (expand-file-name "bin" tnoda/gopath))

  (setenv "GOPATH" tnoda/gopath)
  (setenv "PATH" (concat (getenv "PATH") ":" tnoda/gopath-bin))
  (add-to-list 'exec-path tnoda/gopath-bin)

  (require 'go-mode)

  (defun tnoda/gofmt-before-save ()
    "The original version of go-fmt may break the kill-region function,
  if it has an advised version."
    (interactive)
    (when (eq major-mode 'go-mode)
      (sense-region-off)
      (gofmt)
      (sense-region-on)))

  (add-hook 'before-save-hook 'tnoda/gofmt-before-save)
  (add-hook 'go-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'go-mode-hook 'turn-on-smartparens-strict-mode)
  (add-hook 'go-mode-hook 'tnoda/increase-line-spacing)
  (add-hook 'go-mode-hook 'subword-mode)

  (define-key go-mode-map (kbd "M-.") 'godef-jump)
  (define-key go-mode-map (kbd "M-,") 'pop-tag-mark)
  (define-key go-mode-map (kbd "C-c C-j") 'go-goto-imports)
  (define-key go-mode-map (kbd "C-c C-r") 'go-remove-unused-imports)
  (define-key go-mode-map (kbd "C-c C-d") 'godoc)

  (defun tnoda/go-mode-tab-width ()
    (setq tab-width 4))

  (defun tnoda/go-mode-turn-off-auto-save-buffers ()
    (setq-local auto-save-buffers-enhanced-activity-flag nil))

  (add-hook 'go-mode-hook 'tnoda/go-mode-tab-width)
  (add-hook 'go-mode-hook 'tnoda/go-mode-turn-off-auto-save-buffers)

#+END_SRC

*** go-eldoc
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'go-eldoc)

#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'flycheck)
  (add-hook 'go-mode-hook 'flycheck-mode)

#+END_SRC

** CSS

*** indent-offset
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/css-mode-indent-offset ()
    (setq-local css-indent-offset 2))

  (add-hook 'css-mode-hook 'tnoda/css-mode-indent-offset)

#+END_SRC

*** mon-css-color                                                    :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (require 'mon-css-color "mon-css-color" t)
    (add-hook 'css-mode-hook 'css-color-turn-on-in-buffer))

#+END_SRC

*** emmet-mode                                                       :cask:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'emmet-mode)
  (setq emmet-indentation 2)

  (defun tnoda/turn-on-emmet-mode ()
    (emmet-mode 1))

  (add-hook 'css-mode-hook 'tnoda/turn-on-emmet-mode)
  (add-hook 'css-mode-hook 'turn-on-smartparens-strict-mode)

#+END_SRC

** ESS (R)
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ess-site)

  (add-hook 'inferior-ess-mode-hook 'turn-on-smartparens-mode)

#+END_SRC


* Twitter                                                    :cask:rubikitch:

twittering-mode.el を使う．

** =M-x twit= で =twittering-mode=.                                 :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'twittering-mode)
#+END_SRC

** 各 tweet 一行で表示．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq twittering-status-format "%s >\n%T\n")

#+END_SRC

** 認証済み OAuth トークンを PGP で暗号化して保存．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq twittering-use-master-password t)
#+END_SRC

* Helm

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'helm)
  (setq helm-command-prefix-key "C-c h")
  (require 'helm-config)
  (require 'helm-mode)
  (require 'helm-eshell)
  (require 'helm-files)
  (require 'helm-grep)
  (require 'helm-info)
  (require 'helm-ls-git)
  (define-key ctl-x-map (kbd "C-j") 'skk-mode)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (define-key ctl-x-map (kbd "b") 'helm-mini)
  (define-key helm-command-map (kbd "a") 'helm-apropos)
  (define-key helm-command-map (kbd "g") 'helm-ls-git-ls)
  (define-key helm-command-map (kbd "i") 'helm-info-emacs)
  (define-key helm-command-map (kbd "l") 'helm-locate)
  (define-key helm-command-map (kbd "m") 'helm-man-woman)
  (define-key helm-command-map (kbd "o") 'helm-occur)
  (define-key helm-command-map (kbd "r") 'helm-resume)
  (define-key helm-command-map (kbd "s") 'helm-semantic-or-imenu)

  (add-to-list 'helm-completing-read-handlers-alist '(find-file . nil))
  (add-to-list 'helm-completing-read-handlers-alist '(execute-extended-command . nil))

  (setq
   helm-google-suggest-use-curl-p t
   helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
   helm-quick-update t ; do not display invisible candidates
   helm-idle-delay 0.01 ; be idle for this many seconds, before updating in delayed sources.
   helm-input-idle-delay 0.01 ; be idle for this many seconds, before updating candidate buffer
   helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.
   helm-split-window-default-side 'other ;; open helm buffer in another window
   )

  (set-face-attribute 'helm-selection
                      'nil
                      :background "DarkGreen"
                      :foreground "Gray94")

  (helm-mode 1)

#+END_SRC

** helm-pydoc

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'helm-pydoc)
  (define-key python-mode-map (kbd "<f1>") 'helm-pydoc)

#+END_SRC

** helm-dash
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'helm-dash)

  (define-key helm-command-map (kbd "d") 'helm-dash)
  (setq helm-dash-docsets-url "https://raw.githubusercontent.com/Kapeli/feeds/master")
  (defvar tnoda/helm-dash-docsets '("Go" "Python_3" "Scala" "Java_SE8" "Clojure" "Ruby_2"))

  (defun tnoda/install-helm-dash-common-docsets
    ()
    (interactive)
    (--map (helm-dash-install-docset it) tnoda/helm-dash-docsetts))

#+END_SRC

*** Go
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/set-helm-dash-docsets-go
    ()
    (setq-local helm-dash-docsets '("Go")))

  (add-hook 'go-mode-hook 'tnoda/set-helm-dash-docsets-go)

#+END_SRC

*** Python
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/set-helm-dash-docsets-python
    ()
    (setq-local helm-dash-docsets '("Python_3")))

  (add-hook 'python-mode-hook 'tnoda/set-helm-dash-docsets-python)

#+END_SRC

** helm-descbinds
#+BEGIN_SRC emacs-lisp :tangle yes
  (helm-descbinds-install)

#+END_SRC


* SDIC
** インストール
#+BEGIN_SRC sh :tangle install-sdic.sh :var src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app info_dir=tnoda-info-dir prefix=tnoda-dotfiles-dir
  cd $src_dir
  curl http://www.namazu.org/~tsuchiya/sdic/sdic-2.1.3.tar.gz | tar zxf -
  cd sdic-2.1.3
  curl -O http://www.namazu.org/~tsuchiya/sdic/data/gene95.tar.gz
  curl -O http://www.namazu.org/~tsuchiya/sdic/data/edict.gz
  ./configure --prefix=$prefix --infodir=$info_dir --with-emacs=$emacs  --with-lispdir=$elisp_dir --with-dictdir=$prefix/share/dict
  make install
  make install-info
  make dict
  make install-dict
#+END_SRC

** =C-c w= で SDIC 辞書検索．                                          :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'sdic)
  (global-set-key (kbd "C-c w") 'sdic-describe-word-at-point)
#+END_SRC

** popwin を使って，SDIC の検索結果を下に表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'special-display-buffer-names "*sdic*")
  (if (boundp 'popwin:special-display-config)
      (push '("*sdic*" :position bottom) popwin:special-display-config))

#+END_SRC

* Org Mode                                                              :git:

** Install
#+BEGIN_SRC sh :tangle install-org.sh :var src_dir=tnoda-src-dir prefix=tnoda-dotfiles-dir info_dir=tnoda-info-dir emacs=emacs-app
  ORG_VERSION=8.2.6
  cd $src_dir
  curl -O http://orgmode.org/org-${ORG_VERSION}.tar.gz
  tar zxf org-${ORG_VERSION}.tar.gz
  rm -f org
  ln -s org-${ORG_VERSION} org
  cd org
  make EMACS=$emacs compile
  make EMACS=$emacs info
  cd $info_dir
  rm -f org
  ln -s $src_dir/org/doc/org .
#+END_SRC

** org-mew.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-mew)
#+END_SRC

** Common
*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-habit)
#+END_SRC

*** =~/org= で Org を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-directory "~/org")
#+END_SRC

*** =org-extend-today-until=
My day really ends at two o'clock in the morning.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-extend-today-until 2)
#+END_SRC

*** =C-,== と =C-'== に割り当てられる =org-cycle-agenda-files= を無効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (rassq-delete-all 'org-cycle-agenda-files org-mode-map)
#+END_SRC

*** =org-edit-special= 中は auto-save-buffers を停止する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (lexical-let ((previous-active-p))
    (defadvice org-edit-src-code (before tnoda/auto-save-buffers-toggle activate)
      "Disable auto-save-buffers."
      (setq previous-active-p  auto-save-buffers-enhanced-activity-flag)
      (setq auto-save-buffers-active-p nil))
    (defadvice org-edit-src-exit (after tndoa/auto-save-buffers-toggle activate)
      "Recover auto-save-buffers."
      (setq auto-save-buffers-enhanced-activity-flag previous-active-p)))
#+END_SRC

停止しないと，src ブロックを編集している最中に，

#+BEGIN_QUOTE
foo.org has changed since visited or saved.  Save anyway? (y or n) !
foo.org changed on disk; really edit the buffer? (y, n, r or C-h) 
File on disk now will become a backup file if you save these changes.
#+END_QUOTE

と怒られる．

*** ~=code=~ の face を org-code から =font-lock-constant-face= に変更する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-emphasis-alist
        (cons '("=" font-lock-constant-face "<code>" "</code>" verbatim)
              (remove-if (lambda (x)
                           (equal "=" (car x)))
                         org-emphasis-alist)))
#+END_SRC
** 見出し入力の改善．
*** =C-M-RET= で =org-insert-substring=                                 :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)
#+END_SRC

*** =C-u C-RET= で一レベル下の見出し， =C-u C-u C-RET= で一レベル上の見出し． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-insert-heading-respect-content (arg)
    (interactive "p")
    (org-insert-heading-respect-content arg)
    (case arg
      (4 (org-do-demote))
      (16 (org-do-promote))))
  
  (define-key org-mode-map (kbd "<C-return>") 'tnoda/org-insert-heading-respect-content)
#+END_SRC

** Link
*** =C-c l= で org-store-link.                                          :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c l") 'org-store-link)
#+END_SRC

*** Using links outside Org
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c L") 'org-insert-link-global)
  (global-set-key (kbd "C-c o") 'org-open-at-point-global)

#+END_SRC

** Refile
main.org のトップレベルに refile できるようにする．

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets
        '(("main.org" . (:level . 1))))
#+END_SRC

** ~TODO~

*** ~TODO~ keywords
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keywords
        '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)")
          (sequence "WAITING(w@/!)" "|")
          (sequence "APPT(a)" "|")
          (sequence "|" "CANCELED(c@)")
          (sequence "|" "DEFERRED(f@)")
          (sequence "|" "DELEGATED(g@)")))
#+END_SRC

*** Customize Org TODO faces
#+BEGIN_SRC emacs-lisp :tangle yes
  (defface tnoda/org-todo
    '((t (:foreground "gray" :background "dark red" :bold t)))
    "Font for TODO keywords.")
  
  (defface tnoda/org-started
    '((t (:foreground "gold1" :background "gray10" :bold t)))
    "Font for STARTED keywords.")
  
  (defface tnoda/org-waiting
    '((t (:foreground "gray" :background "green4" :bold t)))
    "Font for WAITING keywords.")
  
  (defface tnoda/org-appt
    '((t (:foreground "gray" :background "DodgerBlue4" :bold t)))
    "Font for APPT keywords")
  
  (setq org-todo-keyword-faces
        '(("TODO" . tnoda/org-todo)
          ("STARTED" . tnoda/org-started)
          ("WAITING" . tnoda/org-waiting)
          ("APPT" . tnoda/org-appt)))
#+END_SRC

*** Automatically change to DONE when all children are done.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
  
  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC

Retrieved from [[info:org#Breaking%20down%20tasks][info:org#Breaking down tasks]]

*** =TODO= ステータスが =STARTED= に変化したらクロックを開始する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sacha/org-clock-in-if-starting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "STARTED")
               (not (string= org-last-state org-state)))
      (org-clock-in)))
  (add-hook 'org-after-todo-state-change-hook
            'sacha/org-clock-in-if-starting)
  ;; (defadvice org-clock-in (after sacha activate)
  ;;   "Set this task's status to 'STARTED'."
  ;;   (org-todo "STARTED"))
  (defun sacha/org-clock-out-if-waiting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "WAITING")
               (not (string= org-last-state org-state)))
      (org-clock-out)))
  (add-hook 'org-after-todo-state-change-hook
            'sacha/org-clock-out-if-waiting)
#+END_SRC

** Tags

*** Globally defined tags
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-tag-persistent-alist '((:startgroup . nil)
                                   ("home" . ?h)
                                   ("office" . ?o)
                                   (:endgroup . nil)
                                   ("computer" . ?c)
                                   ("errands" . ?e)
                                   ("library" . ?l)
                                   ("reading" . ?r)))
#+END_SRC

** Capture

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-default-notes-file (expand-file-name "journal.org" org-directory))
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

*** Templates

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-capture-templates
        '(("j" "Journal" entry (file "") "* %?   %T\n"
           :prepend t
           :clock-keep t
           :empty-lines 1
           :kill-buffer t)
          ("t" "Todo" entry (file+headline tnoda/gtd-file "Tasks")
           "* TODO %? \n\n%i\n%a\nAdded: %U\n\n"
           :prepend t
           :clock-keep t
           :empty-lines 1
           :kill-buffer t)
          ("m" "Morning Routine" entry (file "")
           "* Morning Routine %U\n\n%[~/org/morning_routine.org]"
           :prepend t
           :clock-in t
           :empty-lines 1
           :kill-buffer t)
          ("r" "Daily Review" entry (file "")
           "* Daily Review %U\n\n%[~/org/daily_review.org]"
           :prepend t
           :clock-in t
           :empty-lines 1
           :kill-buffer t)))
#+END_SRC

** GTD
*** =M-x gtd= で =main.org= を開く．                              :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst tnoda/gtd-file (expand-file-name "main.org" org-directory))
    (defun gtd ()
      (interactive)
      (find-file tnoda/gtd-file))
#+END_SRC

*** =M-x notes= で =notes.org= を開く．                           :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun notes ()
    (interactive)
    (find-file org-default-notes-file))
#+END_SRC
  
*** =M-x flagged= で =flagged.org= を開く．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun flagged ()
    (interactive)
    (find-file (expand-file-name "flagged.org" org-directory)))
#+END_SRC

*** =C-c g= で =org-clock-goto=.                                        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c g") 'org-clock-goto)
#+END_SRC

** Agenda

*** Agenda files
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files (-concat (-list tnoda/gtd-file org-default-notes-file)
                                  (--map (expand-file-name it org-directory)
                                         '("projects.org"
                                           "habits.org"
                                           "financial.org"
                                           "family.org"))))
#+END_SRC

*** =<S-f7>= と =<f7>= に Org Agenda を開くコマンドを割り当てる．     :key:
- 一日の始まり→ =<S-f7>= ... Home Lists
- タスクの確認→ =<f7>= ... Daily Action List
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-custom-commands
        '(("H" "Home Lists"
           ((agenda "")
            (tags-todo "family")
            (tags-todo "home")
            (tags-todo "office")
            (tags-todo "errands")
            (tags "library")
            (tags "reading")))
          ("D" "Daily Action List"
           ((agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        (org-deadline-warning-days 0)))))))

  (defun tnoda/org-agenda-home-lists ()
    (interactive)
    (org-agenda nil "H"))
  (global-set-key (kbd "<S-f7>") 'tnoda/org-agenda-home-lists)
  (defun tnoda/org-agenda-daily-action-list ()
    (interactive)
    (org-agenda nil "D"))
  (global-set-key (kbd "<f7>") 'tnoda/org-agenda-daily-action-list)
#+END_SRC

*** そのほかの設定
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-include-diary t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-start-on-weekday nil)
#+END_SRC
*** Faces
#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-attribute 'org-column nil
                      :background "gray16"
                      :strike-through nil
                      :underline nil
                      :height 160
                      :family "Ricty")
  (set-face-attribute 'org-column-title nil
                      :background "grey30"
                      :underline t
                      :family "Ricty")
#+END_SRC

** Mobile

#+begin_src emacs-lisp :tangle yes
  (when (load "~/.org-mobile-encryption-password.el" t)
    (setq org-mobile-use-encryption t)
    (setq org-mobile-inbox-for-pull "~/org/flagged.org")
    (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg"))

#+end_src

** Exporting
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'org-export-backends 'beamer)
#+END_SRC

*** Latex
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-latex-pdf-process '("/usr/texbin/lualatex %b"))
  (setq org-latex-default-class "ltjsarticle}")
  (add-to-list 'org-latex-default-packages-alist '("" "luatexja" nil))
  (add-to-list 'org-latex-default-packages-alist '("hiragino-pron" "luatexja-preset" nil))

*** Beamer
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-beamer-frame-level 2)
#+END_SRC

*** Inhibit HTML validation link
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-html-validation-link nil)

#+END_SRC

** Babel
*** Emacs Lisp 以外の言語も有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (R . t)
     (clojure . t)
     (scala . t)
     (ditaa . t)
     (dot . t)
     (haskell . t)
     (java . t)
     (js . t)
     (latex . t)
     (org . t)
     (ruby . t)
     (sh . t)
     (latex . t)))
#+END_SRC

*** Use graphviz-dot-mode when editing dot blocks.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'graphviz-dot-mode)
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

*** コードブロックのフォント修飾は，Emacs が重くなるのでやめる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively nil)
#+END_SRC

*** コードブロックを確認無しに実行する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-confirm-babel-evaluate nil)
#+END_SRC


** =el= 同時押しで emacs-lisp の src ブロック挿入．                       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-babel-demarcate-block-as-elisp ()
    (interactive)
    (insert "#+BEGIN_SRC emacs-lisp :tangle yes\n\n#+END_SRC")
    (org-indent-line)
    (previous-line)
    (org-edit-special))
  (key-chord-define org-mode-map "el" 'tnoda/org-babel-demarcate-block-as-elisp)
#+END_SRC

** =dm= 同時押しで markdown の src ブロック挿入．                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-babel-demarcate-block-as-markdown ()
    (interactive)
    (insert "#+BEGIN_SRC markdown :tangle yes\n\n#+END_SRC")
    (org-indent-line)
    (previous-line)
    (org-edit-special))
  (key-chord-define org-mode-map "dm" 'tnoda/org-babel-demarcate-block-as-markdown)
#+END_SRC

** Easy Templates
+ =<s= で =#+STARTUP: =
+ =<S= で =#+SETUPFILE: =
+ =<p= で =#+PROPERTY: =
+ =<b= で beamer

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-structure-template-alist
        (remove-if #'(lambda (x) (member (car x) '("s" "S" "p")))
                   org-structure-template-alist))
  (push '("s" "#+STARTUP: ") org-structure-template-alist)
  (push '("S" "#+SETUPFILE: %file ?") org-structure-template-alist)
  (push '("p" "#+PROPERTY: ") org-structure-template-alist)
  (push '("b" "#+STARTUP: beamer
  ,#+LaTeX_CLASS: beamer
  ,#+LaTeX_CLASS_OPTIONS: [presentation]
  ,#+BEAMER_FRAME_LEVEL: 2
  ,#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
  ,#+OPTIONS: toc:nil
  ,#+BEAMER_HEADER: \\usepackage{tnoda-beamer}
  ,#+AUTHOR: Takahiro Noda
  ,#+DATE: 2013-04-01
  ,#+EMAIL: foo@example.com
  ,#+TITLE: 
  # (org-beamer-mode)?") org-structure-template-alist)
#+END_SRC

** Patch ob-clojure to work with nrepl

Retrieved from https://raw.github.com/lambdatronic/org-babel-example/master/org/potter.org,
on [2013-03-06 Wed]

#+BEGIN_SRC emacs-lisp :tangle yes
  (declare-function nrepl-send-string-sync "ext:nrepl" (code &optional ns))
  
  (defun org-babel-execute:clojure (body params)
    "Execute a block of Clojure code with Babel."
    (require 'nrepl)
    (with-temp-buffer
      (insert (org-babel-expand-body:clojure body params))
      ((lambda (result)
         (let ((result-params (cdr (assoc :result-params params))))
           (if (or (member "scalar" result-params)
                   (member "verbatim" result-params))
               result
             (condition-case nil (org-babel-script-escape result)
               (error result)))))
       (plist-get (nrepl-send-string-sync
                   (buffer-substring-no-properties (point-min) (point-max))
                   (cdr (assoc :package params)))
                  :value))))
#+END_SRC

Under nrepl.el + NREPL:

1. M-x org-babel-tangle (regenerates source files)
2. M-x nrepl-jack-in (starts nrepl.el + NREPL)
3. M-x nrepl-interaction-mode (to enable NREPL keybindings in this buffer)
4. C-c C-c (from within toplevel-load-block, loads source code into NREPL)
5. M-x org-export-as-html (regenerate woven HTML documentation)
